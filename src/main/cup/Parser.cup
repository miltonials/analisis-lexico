package com.compi;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.lang.Math;

//para errores
import java_cup.runtime.Symbol;

//para tablas de simbolos
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

/**
 * Clase principal del compilador
 */
class Parser;


action code {:
        HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<String, ArrayList<String>>();
        String currentHash;
        boolean compila = true;
        String vName;
        String vValue;
        char vValueCharmander;

        /**
         * Imprime la tabla de símbolos
        */
        public void imprimirTablaSimbolos () {
            System.out.println("_________________________Tablas de símbolos_________________________");
            for(String key: listaTablasSimbolos.keySet()) {
                System.out.println("Tabla de símbolos: " + key);
                System.out.println("valores: ");
                for (String item : listaTablasSimbolos.get(key)) {
                    System.out.println(item);
                }
                System.out.println("");
            }
            System.out.println("______________________________________________________________________");
        }

        /**
         * Agrega una tabla de símbolos a la lista de tablas de símbolos
         * @param tipo tipo de la tabla de símbolos
         * @param nombreFuncion nombre de la función a la que pertenece la tabla de símbolos
         */
        public void agregarTablaSimbolos (String tipo, String nombreFuncion) {
            String tipoTabla = "Tipo: " + tipo;
            ArrayList<String> funcionMain = new ArrayList<String>();
            currentHash = nombreFuncion;
            funcionMain.add(tipoTabla);
            listaTablasSimbolos.put(currentHash, funcionMain);
        }

        /*
         * muestra el error de sintaxis
         * @param mensaje error
         */
        public void error(String mensaje) {
            System.out.println(mensaje);
        }
:}

parser code {:
        IdLexer miParser;
        // Habilitar la depuración
        boolean _cup_debug = true;
        List<String> syntaxErrors = new ArrayList<>();

        String tipoRetornoActual = null;

        /**
         * Establece el tipo de retorno actual
         * @param tipo tipo de retorno actual
         */
        public void setTipoRetorno(String tipo) {
                tipoRetornoActual = tipo;
        }

        /**
         * Verifica que el tipo de retorno sea el correcto
         * @param tipoReal tipo de retorno real
         */
        public void checkTipoRetorno(String tipoReal) {
                if (tipoRetornoActual != null && !tipoRetornoActual.equals(tipoReal)) {
                        System.err.println("Tipo de retorno incorrecto. Se esperaba: " + tipoRetornoActual + ", pero se encontró: " + tipoReal);
                }
        }

        // Agregar un método para obtener la lista de errores después del análisis
        /**
         * Obtiene la lista de errores de sintaxis
         * @return lista de errores de sintaxis
         */
        public List<String> getSyntaxErrors() {
                return syntaxErrors;
        }

        @SuppressWarnings("deprecation")
        public Parser(IdLexer miParser) {
                this.miParser = miParser;
                this.symbolFactory = new DefaultSymbolFactory();
        }

        /**
         * captura los errores de sintaxis 
         * @param s error
         */
        public void syntax_error(Symbol s) {
                try {
                        String errorMessage = "Error de sintaxis: " + s.value + " en la línea " + (s.left + 1) + " columna " + (s.right + 1);
                        System.err.println(errorMessage);
                        // Agregar lógica adicional si es necesario para errores recuperables
                        //throw new Exception("Error recuperable");
                } catch (Exception e) {
                        System.err.println("Hola");
                        System.err.println("Error de sintaxis: " + e.getMessage());
                }
        }

        /**
         * captura los errores de sintaxis no recuperables
         * @param s error
         */
        public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
                String errorMessage = "Error de sintaxis no recuperable: " + s.value + " en la línea " + (s.left + 1) + " columna " + (s.right + 1);
                System.err.println(errorMessage);

                // Agregar lógica adicional si es necesario para errores no recuperables
                // throw new Exception("Error no recuperable");
        }
:}


init with {: :};

scan with {: return miParser.next_token(); :};

/* Terminales */

// Operadores aritméticos binarios
terminal String RUDOLPH; // +
terminal String DASHER; // -
terminal String  DANCER; // /
terminal String  PRANCER; // // (division entera)
terminal String  VIXEN; // *
terminal String  COMET; // ~
terminal String CUPID; // **
// Operadores aritméticos unarios
terminal String  GRINCH; // ++
terminal String  QUIEN; // --
// Operadores relacionales
terminal String  HERMEY; // <
terminal String  BUDDY; // =<
terminal String  JINGLE; // >
terminal String JANGLE; // >=
terminal String  PEPPERMINT; // ==
terminal String  WUNORSE; // !=
// Operadores lógicos
terminal String  MELCHOR; // ^
terminal String  GASPAR; // #
terminal String BALTASAR; // !
terminal  LOCAL; // variable

// Tipos
terminal String PERSONA; // identificador
terminal String SANTACLAUS; // int
terminal String PERENOEL; // float
terminal String FATHERCHRISTMAS; // boolean
terminal String KRISKRINGLE; // char
terminal String DEDMOROZ; // string
terminal Integer[] PAPANOEL; // array
terminal Integer L_SANTACLAUS; // literal int
terminal Double L_PERENOEL; // literal float
//terminal Boolean L_FATHERCHRISTMAS; // literal boolean
terminal String L_FATHERCHRISTMAS; // literal boolean
terminal String L_KRISKRINGLE; // literal char
terminal String L_DEDMOROZ; // literal string
//terminal Integer[] L_PAPANOEL; // literal array

// Parentesis
terminal String ABRECUENTO; // (
terminal String CIERRECUENTO; // )
terminal String ABREEMPAQUE; // [
terminal String CIERREEMPAQUE; // ]
terminal String ABREREGALO; // {
terminal String CIERRAREGALO; // }

// Estructuras de control
terminal String ELFO;//if
terminal String HADA;//else
terminal String DUENDE;//else
terminal String ENVUELVE;//for
terminal String HACE;//do
terminal String REVISA;//until
terminal String ENVIA;//return
terminal String CORTA;//break

// Entrada y salida
terminal Integer NARRA;//print
terminal Integer ESCUCHA;//read 

// Fin de expresión
terminal  FINREGALO; // |

// Lexema separador
terminal String COMA; //,

// Asignación
terminal Integer ENTREGA;//<=

// Comentarios
// son ignorados por el compilador

// Funciones
terminal Integer MAIN; //main
terminal Integer REGALO; // definicion de funcion 

//-------------------------------------------------------------------------------------- NO Terminales
non terminal navidad; // Símbolo inicial ✅
non terminal bolsanavidena; // produccion para funciones ✅
non terminal regaloprincipal; // produccion para main ✅
non terminal regalofuncional; // produccion para funciones ✅
non terminal tipoRegalo; // produccion para tipo de funcion ✅
non terminal monnos; // produccion para parametros ✅
non terminal juguetes; // produccion para cuerpo de funcion ✅
non terminal juguete; // produccion para cuerpo de funcion ✅
non terminal tallerDeJuguetes; // produccion para cuerpo de funcion ✅
non terminal piezaJuguete; // produccion para cuerpo de funcion ✅
non terminal gomaLocaAritmetica; // produccion para cuerpo de funcion ✅
non terminal gomaLocaRelacional; // produccion para cuerpo de funcion ✅
non terminal gomaLocaLogica; // produccion para cuerpo de funcion ✅
non terminal asignarJuguete;
non terminal tipoJuguete;
non terminal subtipoRegalo;
non terminal gomasNavidenas;
non terminal piezaImportada;
non terminal estampillasNavidena;
//-------------------------------------------------------------------------------------- PRECEDENCIA






//-------------------------------------------------------------------------------------- PRODUCCIONES
/* Símbolo inicial y producciones gramaticales*/
start with navidad;

/* Producciones gramaticales */
navidad ::= 
        bolsanavidena
        {:
            imprimirTablaSimbolos();
            System.out.println("Fin de ejecución");
            
            if (compila) {
                System.out.println("Compilación exitosa");
            } else {
                System.out.println("Compilación fallida");
            }
        :}
        ;

bolsanavidena ::=  regaloprincipal
                | regalofuncional regaloprincipal;

regaloprincipal ::= REGALO SANTACLAUS MAIN ABRECUENTO  CIERRECUENTO ABREREGALO
                        {:
                            agregarTablaSimbolos("int", "main");
                        :}
                        juguetes
                    CIERRAREGALO;

regalofuncional ::= REGALO tipoRegalo:tipo PERSONA:nombre ABRECUENTO monnos CIERRECUENTO ABREREGALO
                    {:
                        agregarTablaSimbolos(tipo.toString(), nombre.toString());
                    :}
                    juguetes
                    CIERRAREGALO
                    |
                    REGALO tipoRegalo:tipo PERSONA:nombre ABRECUENTO CIERRECUENTO ABREREGALO
                    {:
                        agregarTablaSimbolos(tipo.toString(), nombre.toString());
                    :}
                    juguetes
                    CIERRAREGALO
                    ;

tipoRegalo ::=  PERENOEL:tipo {: RESULT =  tipo; :}
            | FATHERCHRISTMAS:tipo {: RESULT =  tipo; :}
            | subtipoRegalo:tipo {: RESULT =  tipo; :}
            | DEDMOROZ:tipo {: RESULT =  tipo; :}
            | PAPANOEL:tipo {: RESULT =  tipo; :}
            ;

subtipoRegalo ::= SANTACLAUS:tipo {: RESULT =  tipo; :}
                | KRISKRINGLE:tipo {: RESULT =  tipo; :}
                ;

monnos ::= tipoRegalo:tipo PERSONA:nombre
                {:
                    agregarTablaSimbolos(tipo.toString(), nombre.toString());
                :} 
            | tipoRegalo:tipo PERSONA:nombre COMA monnos;


juguetes ::= juguete FINREGALO
            | juguete FINREGALO juguetes;

juguete ::= asignarJuguete
            | piezaImportada
            | CORTA
            | ENVIA tallerDeJuguetes
            | NARRA tallerDeJuguetes
            | ESCUCHA tallerDeJuguetes
            // | jugueteRelacional
            // | jugueteLogico
            // | jugueteEntradaSalida
            // | jugueteEstructuraControl
            // | jugueteFuncion
            ;

asignarJuguete ::= LOCAL tipoJuguete PERSONA ENTREGA tallerDeJuguetes
                    | LOCAL tipoJuguete PERSONA
                    | PERSONA ENTREGA tallerDeJuguetes

                    | LOCAL tipoJuguete PERSONA ENTREGA ABREEMPAQUE estampillasNavidena CIERREEMPAQUE
                    | PERSONA ABREEMPAQUE tallerDeJuguetes CIERREEMPAQUE ENTREGA tallerDeJuguetes
                    | PERSONA ENTREGA ABREEMPAQUE estampillasNavidena CIERREEMPAQUE
                    ;

tipoJuguete ::= tipoRegalo:tipo {: RESULT =  tipo; :}
            |  tipoRegalo:tipo ABREEMPAQUE tallerDeJuguetes CIERREEMPAQUE
            ;


//para crear los literales
tallerDeJuguetes ::= piezaJuguete
                    | piezaJuguete gomasNavidenas tallerDeJuguetes
                    | GRINCH:operador tallerDeJuguetes
                    | QUIEN:operador tallerDeJuguetes
                    | BALTASAR:operador tallerDeJuguetes
                    | ABRECUENTO tallerDeJuguetes CIERRECUENTO // ( expr )
                    | ABRECUENTO tallerDeJuguetes CIERRECUENTO gomasNavidenas tallerDeJuguetes // ( expr ) gomasNavidenas tallerDeJuguetes
                    ;

gomasNavidenas ::= gomaLocaAritmetica
                | gomaLocaRelacional
                | gomaLocaLogica
                ;

piezaJuguete ::= L_SANTACLAUS:val {: RESULT =  val; :}
            | L_PERENOEL:val {: RESULT =  val; :}
            | L_FATHERCHRISTMAS:val {: RESULT =  val; :}
            | L_KRISKRINGLE:val {: RESULT =  val; :}
            | L_DEDMOROZ:val {: RESULT =  val; :}
            | PERSONA:nombre ABREEMPAQUE tallerDeJuguetes:val CIERREEMPAQUE //indice de array
                {:
                    RESULT = nombre + "[" + "val.toString()" + "]";//TODO: agregar a la tabla de simbolos
                :}
            | PERSONA:nombre {: RESULT =  nombre; :}
            | piezaImportada
            ;

piezaImportada ::= PERSONA ABRECUENTO CIERRECUENTO
                | PERSONA ABRECUENTO estampillasNavidena CIERRECUENTO
                ;

estampillasNavidena ::= tallerDeJuguetes
                    | tallerDeJuguetes COMA estampillasNavidena
                    ;

gomaLocaAritmetica ::= RUDOLPH:operador {: RESULT = operador; :}
                    | DASHER:operador {: RESULT = operador; :}
                    | DANCER:operador {: RESULT = operador; :}
                    | PRANCER:operador {: RESULT = operador; :}
                    | VIXEN:operador {: RESULT = operador; :}
                    | COMET:operador {: RESULT = operador; :}
                    | CUPID:operador {: RESULT = operador; :}
                    ;

gomaLocaRelacional ::= HERMEY:operador {: RESULT = operador; :}
                    | BUDDY:operador {: RESULT = operador; :}
                    | JINGLE:operador {: RESULT = operador; :}
                    | JANGLE:operador {: RESULT = operador; :}
                    | PEPPERMINT:operador {: RESULT = operador; :}
                    | WUNORSE:operador {: RESULT = operador; :}
                    ;

gomaLocaLogica ::= MELCHOR:operador {: RESULT = operador; :}
                | GASPAR:operador {: RESULT = operador; :}
                ;

/*
TODO: permitir que se pueda llamar funciones con parametros y sin parametros (un parametro puede ser una funcion)✅
TODO: permitir que se pueda llamar una funcion como operando✅
TODO: permitir creación de arreglos✅
TODO: permitir Entrada y salida✅
TODO: permitir Estructuras de control❌
TODO: permitir ciclos❌
*/