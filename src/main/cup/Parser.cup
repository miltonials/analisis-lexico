package com.compi;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.lang.Math;

//para errores
import java_cup.runtime.Symbol;

//para tablas de simbolos
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

/**
 * Clase principal del compilador
 */
class Parser;


action code {:
        HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<String, ArrayList<String>>();
        String currentHash;
        boolean compila = true;
        String vName;
        String vValue;
        char vValueCharmander;
        boolean primeraOp = true;

        StringBuffer cod3D = new StringBuffer();
        StringBuffer data = new StringBuffer();
        int currentTemp = 0;
        int cantidadNumeros = 0;

        /**
         * contiene operadores aritmeticos
         * @param variable
        */
        public boolean contieneOperadorAritmetico(String variable) {
            if (variable.contains("+") ){
                return true;
            }
            else if (variable.contains("-") ){
                return true;
            }
            else if (variable.contains("*") ){
                return true;
            }
            else if (variable.contains("/") ){
                return true;
            }
            else if (variable.contains("//") ){
                return true;
            }
            else if (variable.contains("~") ){
                return true;
            }
            else if (variable.contains("**") ){
                return true;
            }
            return false;
        }

        /**
         * Verificar que el parametro no este declarado
         * @param nombreParametro nombre del parametro
        */
        public void verificarDeclaracionParametro(String nombreParametro) {
            if (parametroDeclarado(nombreParametro)) {
                // Capturar y registrar el error semántico
                System.err.println("Error semántico: Parámetro '" + nombreParametro + "' ya declarado.");
                compila = false;
            }
        }
        public boolean parametroDeclarado(String nombreParametro) {
            // Lógica para verificar si la variable está declarada en la tabla de símbolos
            boolean declarada = false;
            for (String item : listaTablasSimbolos.get(currentHash)) {
                if (item.contains(nombreParametro) && item.contains("Parametro")) {
                    declarada = true;
                }
            }
            return declarada;    
        }
        /**
         * Verifica si la variable ya fue declarada
         * @param nombreVariable nombre de la variable
         */
        public void verificarDeclaracionVariable(String nombreVariable) {
            if (!variableDeclarada(nombreVariable)) {
                // Capturar y registrar el error semántico
                System.err.println("Error semántico: Variable '" + nombreVariable + "' no declarada.");
                compila = false;
            }
        }

        public boolean variableDeclarada(String nombreVariable) {
            // Lógica para verificar si la variable está declarada en la tabla de símbolos
            boolean declarada = false;
            for (String item : listaTablasSimbolos.get(currentHash)) {
                if (item.contains(nombreVariable) && !item.contains("Parametro")) {
                    declarada = true;
                }
                else if (item.contains(nombreVariable) && item.contains("Parametro")) {
                    System.err.println("Error semántico: Variable no puede llamarse igual que un parámetro.");
                    declarada = true;
                }
            }
            return declarada;    
        }
        public void verificarDeclaracionFuncion(String nombreFuncion) {
            if (funcionDeclarada(nombreFuncion)) {
                // Capturar y registrar el error semántico
                System.err.println("Error semántico: Función '" + nombreFuncion + "' ya declarada.");
                compila = false;
            }
        }

        public boolean funcionDeclarada(String nombreFuncion) {
            // Lógica para verificar si la variable está declarada en la tabla de símbolos
            boolean declarada = false;
            for (String item : listaTablasSimbolos.keySet()) {
                if (item.contains(nombreFuncion)) {
                    declarada = true;
                }
            }
            return declarada;    
        }

        /**
         * Verifica que el tipo de retorno sea el correcto
         * @param tipoReal tipo de retorno real
         * @param tipoEsperado tipo de retorno esperado
        */
        public boolean verificarTipoRetorno(String actual) {
            if (tipodeRetorno(actual)) {
                return true;
            }
            // Capturar y registrar el error semántico
            System.err.println("Error semántico: Tipo de retorno incorrecto en la función " + currentHash + ".");
            compila = false;
            return false;
        }

        public boolean tipodeRetorno(String actual) {
            // Lógica para verificar si lo que se retorna es del tipo correcto
            boolean isTrue = false;
            for (String item : listaTablasSimbolos.get(currentHash)) {
                if (item.contains("Tipo: ")) {
                    String tipoFunc = item.split(":")[1].replace(" ", "");
                    if(tipoFunc.equals(actual)){
                        isTrue = true;
                    }
                    break;
                }
            }
            return isTrue;   
        }

        /**
         * Imprime la tabla de símbolos
        */
        public void imprimirTablaSimbolos () {
            System.out.println("_________________________Tablas de símbolos_________________________");
            for(String key: listaTablasSimbolos.keySet()) {
                System.out.println("Tabla de símbolos: " + key);
                System.out.println("valores: ");
                for (String item : listaTablasSimbolos.get(key)) {
                    System.out.println(item);
                }
                System.out.println("");
            }
            System.out.println("______________________________________________________________________");
        }

        /**
         * Agrega una tabla de símbolos a la lista de tablas de símbolos
         * @param tipo tipo de la tabla de símbolos
         * @param nombreFuncion nombre de la función a la que pertenece la tabla de símbolos
         */
        public void agregarTablaSimbolos (String tipo, String nombreFuncion) {
            String tipoTabla = "Tipo: " + tipo;
            ArrayList<String> funcionMain = new ArrayList<String>();
            currentHash = nombreFuncion;
            funcionMain.add(tipoTabla);
            listaTablasSimbolos.put(currentHash, funcionMain);
        }

        /*
         * muestra el error de sintaxis
         * @param mensaje error
         */
        public void error(String mensaje) {
            System.out.println(mensaje);
        }
        
        public String getTipo(String id) {
            //buscar en la tabla de simbolos actual
            for (String item : listaTablasSimbolos.get(currentHash)) {
                boolean x = item.contains(id);
                if (item.contains(id)) {
                    String title = item.split(":")[0];
                    return title.substring(title.indexOf("(") + 1, title.indexOf(")"));
                }
            }
            return "null";
        }
        
        /**
        * Checks if the arithmetic operation between two operands is type-compatible.
        * Assumes that the types are either "int" or "float".
        * 
        * @param type1 Type of the first operand
        * @param operator Arithmetic operator
        * @param type2 Type of the second operand
        * @return true if the types are compatible, false otherwise
        */
        public boolean checkAritmeticTypeCompatibility(String type1, String operator, String type2) {
            // Ensure both operands are only "int" or "float"
            boolean isInt1 = type1.equals("int") && (type2.equals("int") || type2.equals(""));
            boolean isInt2 = (type1.equals("int") || type1.equals("")) && type2.equals("int");
            boolean isFloat1 = type1.equals("float") && (type2.equals("float") || type2.equals(""));
            boolean isFloat2 = (type1.equals("float") || type1.equals("")) && type2.equals("float");

            boolean isInt = isInt1 || isInt2;
            boolean isFloat = isFloat1 || isFloat2;
            if (!isInt && !isFloat) {
                return false;
            }

            // Check for specific operator rules
            if (operator.equals("+")
                || operator.equals("-")
                || operator.equals("*")
                || operator.equals("/")
                || operator.equals("//")
                || operator.equals("~")
                || operator.equals("**")
                ) {
                // Allow addition, subtraction, multiplication, and division for both "int" and "float"
                return true;
            }

            // Default case
            return false;
        }

        public void generarArchivo() {
            // Solicitar nombre del generarArchivo
            String filename = "compilado.asm";
            Archivos.crearArchivo(filename);
            Archivos.escribirArchivo(filename, "");
            Archivos.agregarArchivo(filename, ".data\n");
            Archivos.agregarArchivo(filename, data.toString());
            Archivos.agregarArchivo(filename, ".text\n");
            // utilizar StringBuffer cod3D
            Archivos.agregarArchivo(filename, cod3D.toString());
            Archivos.agregarArchivo(filename, "j end_program");
            Archivos.agregarArchivo(filename, Archivos.getContenido("macrosMips.asm"));
        }

:}

parser code {:
    IdLexer miParser;
    // Habilitar la depuración
    boolean _cup_debug = true;
    List<String> syntaxErrors = new ArrayList<>();

    String tipoRetornoActual = null;

    /**
        * Establece el tipo de retorno actual
        * @param tipo tipo de retorno actual
        */
    public void setTipoRetorno(String tipo) {
            tipoRetornoActual = tipo;
    }

    /**
        * Verifica que el tipo de retorno sea el correcto
        * @param tipoReal tipo de retorno real
        */
    public void checkTipoRetorno(String tipoReal) {
            if (tipoRetornoActual != null && !tipoRetornoActual.equals(tipoReal)) {
                    System.err.println("Tipo de retorno incorrecto. Se esperaba: " + tipoRetornoActual + ", pero se encontró: " + tipoReal);
            }
    }

    // Agregar un método para obtener la lista de errores después del análisis
    /**
        * Obtiene la lista de errores de sintaxis
        * @return lista de errores de sintaxis
        */
    public List<String> getSyntaxErrors() {
            return syntaxErrors;
    }

    @SuppressWarnings("deprecation")
    public Parser(IdLexer miParser) {
            this.miParser = miParser;
            this.symbolFactory = new DefaultSymbolFactory();
    }

    /**
        * captura los errores de sintaxis 
        * @param s error
        */
    public void syntax_error(Symbol s) {
        try {
            String errorMessage = "Error de sintaxis: " + s.sym + " (" + s.value + ") en la línea " + (s.left+1) + " columna " + (s.right+1);
            System.err.println(errorMessage);
            // Agregar lógica adicional si es necesario para errores recuperables
            // throw new Exception("Error recuperable");
        } catch (Exception e) {
            System.err.println("Hola");
            System.err.println("Error de sintaxis: " + e.getMessage());
        }
    }


    /**
        * captura los errores de sintaxis no recuperables
        * @param s error
        */
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
            String errorMessage = "Error de sintaxis no recuperable: " + s.value + " en la línea " + (s.left + 1) + " columna " + (s.right + 1);
            System.err.println(errorMessage);

            // Agregar lógica adicional si es necesario para errores no recuperables
            // throw new Exception("Error no recuperable");
    }
:}


init with {: :};

scan with {: return miParser.next_token(); :};

/* Terminales */

// Operadores aritméticos binarios
terminal String RUDOLPH; // +
terminal String DASHER; // -
terminal String  DANCER; // /
terminal String  PRANCER; // // (division entera)
terminal String  VIXEN; // *
terminal String  COMET; // ~
terminal String CUPID; // **
// Operadores aritméticos unarios
terminal String  GRINCH; // ++
terminal String  QUIEN; // --
// Operadores relacionales
terminal String  HERMEY; // <
terminal String  BUDDY; // =<
terminal String  JINGLE; // >
terminal String JANGLE; // >=
terminal String  PEPPERMINT; // ==
terminal String  WUNORSE; // !=
// Operadores lógicos
terminal String  MELCHOR; // ^
terminal String  GASPAR; // #
terminal String BALTASAR; // !
terminal  LOCAL; // variable

// Tipos
terminal String PERSONA; // identificador
terminal String SANTACLAUS; // int
terminal String PERENOEL; // float
terminal String FATHERCHRISTMAS; // boolean
terminal String KRISKRINGLE; // char
terminal String DEDMOROZ; // string
terminal Integer[] PAPANOEL; // array
terminal Integer L_SANTACLAUS; // literal int
terminal Double L_PERENOEL; // literal float
//terminal Boolean L_FATHERCHRISTMAS; // literal boolean
terminal String L_FATHERCHRISTMAS; // literal boolean
terminal String L_KRISKRINGLE; // literal char
terminal String L_DEDMOROZ; // literal string
//terminal Integer[] L_PAPANOEL; // literal array

// Parentesis
terminal String ABRECUENTO; // (
terminal String CIERRECUENTO; // )
terminal String ABREEMPAQUE; // [
terminal String CIERREEMPAQUE; // ]
terminal String ABREREGALO; // {
terminal String CIERRAREGALO; // }

// Estructuras de control
terminal String ELFO;//if
terminal String HADA;//else
terminal String DUENDE;//else
terminal String ENVUELVE;//for
terminal String HACE;//do
terminal String REVISA;//until
terminal String ENVIA;//return
terminal String CORTA;//break

// Entrada y salida
terminal Integer NARRA;//print
terminal Integer ESCUCHA;//read 

// Fin de expresión
terminal  FINREGALO; // |

// Lexema separador
terminal String COMA; //,

// Asignación
terminal Integer ENTREGA;//<=

// Comentarios
// son ignorados por el compilador

// Funciones
terminal Integer MAIN; //main
terminal Integer REGALO; // definicion de funcion 

//-------------------------------------------------------------------------------------- NO Terminales
non terminal navidad; // Símbolo inicial ✅
non terminal bolsanavidena; // produccion para funciones ✅
non terminal regaloprincipal; // produccion para main ✅
non terminal regalofuncional; // produccion para funciones ✅
non terminal tipoRegalo; // produccion para tipo de funcion ✅
non terminal monnos; // produccion para parametros ✅
non terminal juguetes; // produccion para cuerpo de funcion ✅
non terminal juguete; // produccion para cuerpo de funcion ✅
non terminal tallerDeJuguetes; // produccion para cuerpo de funcion ✅
non terminal piezaJuguete; // produccion para cuerpo de funcion ✅
non terminal gomaLocaAritmetica; // produccion para cuerpo de funcion ✅
non terminal gomaLocaRelacional; // produccion para cuerpo de funcion ✅
non terminal gomaLocaLogica; // produccion para cuerpo de funcion ✅
non terminal asignarJuguete;
non terminal tipoJuguete;
non terminal subtipoRegalo;
non terminal gomasNavidenas;
non terminal piezaImportada;
non terminal estampillasNavidena;
non terminal estructurarJuguete;
non terminal estructurarJuguete_if;
non terminal estructurarJuguete_elif;
non terminal estructurarJuguete_else;
non terminal condiciones;
non terminal bloque;

non terminal estructurarJuguete_for;
non terminal encabezado_for;
non terminal estructurarJuguete_doUntil;
non terminal bolsaFuncional;
non terminal monnosAux;
//-------------------------------------------------------------------------------------- PRECEDENCIA






//-------------------------------------------------------------------------------------- PRODUCCIONES
/* Símbolo inicial y producciones gramaticales*/
start with navidad;

/* Producciones gramaticales */
navidad ::= 
        bolsanavidena
        {:
            imprimirTablaSimbolos();
            System.out.println("Fin de ejecución");
            
            if (compila) {
                generarArchivo();
                System.out.println("Compilación exitosa");
            } else {
                System.out.println("Compilación fallida");
            }
        :}
        ;

bolsanavidena ::=  regaloprincipal
                | bolsaFuncional regaloprincipal;

bolsaFuncional ::= regalofuncional | bolsaFuncional regalofuncional;

regaloprincipal ::= REGALO SANTACLAUS MAIN ABRECUENTO  CIERRECUENTO ABREREGALO
                        {:
                            agregarTablaSimbolos("int", "main");
                            cod3D.append("main:\n");
                        :}
                        juguetes
                    CIERRAREGALO;

regalofuncional ::= REGALO tipoRegalo:tipo PERSONA:nombre
                        {:
                            verificarDeclaracionFuncion(nombre);
                            agregarTablaSimbolos(tipo.toString(), nombre.toString());
                            cod3D.append(nombre + ":\n");
                        :} 
                    monnosAux ABREREGALO
                        juguetes
                    CIERRAREGALO
                    ;
                    
monnosAux ::= ABRECUENTO monnos CIERRECUENTO | ABRECUENTO CIERRECUENTO;

tipoRegalo ::=  PERENOEL:tipo {: RESULT =  tipo; :}
            | FATHERCHRISTMAS:tipo {: RESULT =  tipo; :}
            | subtipoRegalo:tipo {: RESULT =  tipo; :}
            | DEDMOROZ:tipo {: RESULT =  tipo; :}
            | PAPANOEL:tipo {: RESULT =  tipo; :}
            ;

subtipoRegalo ::= SANTACLAUS:tipo {: RESULT =  tipo; :}
                | KRISKRINGLE:tipo {: RESULT =  tipo; :}
                ;

monnos ::= tipoRegalo:tipo PERSONA:nombre
                {:
                    verificarDeclaracionParametro(nombre);
                    listaTablasSimbolos.get(currentHash).add( "Parametro (" + tipo.toString() + ") : " + nombre);
                :} 
            | tipoRegalo:tipo PERSONA:nombre COMA monnos
                {:
                    verificarDeclaracionParametro(nombre);
                    listaTablasSimbolos.get(currentHash).add( "Parametro (" + tipo.toString() + ") : " + nombre);
                :};

juguetes ::= juguete
            | juguete juguetes;

juguete ::= asignarJuguete FINREGALO
            | piezaImportada FINREGALO
            | estructurarJuguete
            | CORTA FINREGALO
            | ENVIA tallerDeJuguetes:tp FINREGALO
                {:
                    String tipo = tp.toString().split(":")[tp.toString().split(":").length - 1];
                    verificarTipoRetorno(tipo);
                :}
            | NARRA tallerDeJuguetes:tp FINREGALO
            {:
                String tipo = tp.toString().split(":")[tp.toString().split(":").length - 1];
                boolean isVar = variableDeclarada(vValue);
            :}
            | ESCUCHA tallerDeJuguetes FINREGALO
            ;

asignarJuguete ::= LOCAL tipoJuguete:tipo PERSONA:nombre ENTREGA tallerDeJuguetes:tp
                    {:  
                        if(variableDeclarada(nombre)){
                            System.out.println("Error semántico: Variable '" + nombre + "' ya declarada.");
                            compila = false;
                        }
                        String tipoAux = tp.toString().split(":")[tp.toString().split(":").length - 1];
                        
                        if (!tipoAux.equals(tipo.toString())) {
                            System.out.println("Error semántico: Tipo de dato incorrecto en la asignación de la variable '" + nombre + "'.");
                            compila = false;
                        }
                        System.out.println(tp.toString());
                        //crear una funcion que realice lo de abajo
                        // if (!contieneOperadorAritmetico(tp.toString())) { // si es una operacion aritmetica
                        if(compila){
                            if (tipo.toString().equals("int")) {
                                data.append(nombre + currentHash + ": .word 0\n");
                                
                                for (int i = 1; currentTemp >= i; i++) {
                                    cod3D.append("add $t0, $t0, $t" + i + "\n");
                                }

                                cod3D.append("sw $t0, " + nombre + currentHash + "\n");
                                cod3D.append("lw $a0, "+nombre+currentHash+"\nli $v0, 1\nsyscall\n");

                            } else if (tipo.toString().equals("float")) {
                                data.append(nombre + currentHash + ": .float 0.0\n");
                                //guardo el valor en la variable creada
                                cod3D.append("s.s $f0, " + nombre + currentHash + "\n");
                                //imprimo el valor de la variable
                                cod3D.append("l.s $f12, " + nombre + currentHash + "\nli $v0, 2\nsyscall\n");
                                cantidadNumeros=0;
                            } else if (tipo.toString().equals("bool")) {
                                data.append(nombre + currentHash + ": .word true\n");
                                cod3D.append("sw $t0, " + nombre + currentHash + "\n");
                                cod3D.append("lw $a0, "+nombre+currentHash+"\nli $v0, 1\nsyscall\n");
                            } else if (tipo.toString().equals("char")) {
                                data.append(nombre + currentHash + ": .byte 0\n");
                                cod3D.append("sb $t0, " + nombre + currentHash + "\n");
                                cod3D.append("li $v0, 11\nli $a0, 0\nsyscall\n");

                            } else if (tipo.toString().equals("string")) {
                                data.append(nombre + currentHash + ": .word 0\n");
                                cod3D.append("sw $t0, " + nombre + currentHash + "\n");
                                cod3D.append("lw $a0, "+nombre+currentHash+"\nli $v0, 1\nsyscall\n");
                            }
                        }
                        else {
                            cod3D.append("add $t0, " + tp.toString().split(":")[0] + "\n");
                            cod3D.append("sw $t0, " + nombre + currentHash + "\n");
                            cod3D.append("lw $a0, "+nombre+currentHash+"\nli $v0, 1\nsyscall\n");
                        }

                        primeraOp = true;
                        listaTablasSimbolos.get(currentHash).add( "Variable (" + tipo.toString() + ") : " + nombre + " = " + vValue);
                    :}
                    | LOCAL tipoJuguete:tipo PERSONA:nombre
                    {:
                        if(variableDeclarada(nombre)){
                            System.out.println("Error semántico: Variable '" + nombre + "' ya declarada.");
                            compila = false;
                        }
                        if (tipo.equals("int")){
                            data.append(nombre + currentHash + ": .word 0\n");  
                        } else if (tipo.equals("float")) {
                            data.append(nombre + currentHash + ": .float 0.0\n");
                        } else if (tipo.equals("bool")) {
                            data.append(nombre + currentHash + ": .word 0\n");
                        } else if (tipo.equals("char")) {
                            data.append(nombre + currentHash + ": .byte 0\n");
                        } else if (tipo.equals("string")) {
                            data.append(nombre + currentHash + ": .word 0\n");
                        }
                        // data.append(nombre + currentHash + ": .word 0\n");
                        listaTablasSimbolos.get(currentHash).add( "Variable (" + tipo.toString() + ") : " + nombre);
                    :}
                    | PERSONA:nombre ENTREGA tallerDeJuguetes:tp
                    {:
                        verificarDeclaracionVariable(nombre);
                        String tipoAux = tp.toString().split(":")[tp.toString().split(":").length - 1];  
                        if (!tipoAux.equals(getTipo(nombre))) {
                            System.out.println("Error semántico: Tipo de dato incorrecto en la asignación de la variable '" + nombre + "'.");
                            compila = false;
                        }

                        data.append(nombre + currentHash + ": .word 0\n");
                        listaTablasSimbolos.get(currentHash).add( "Variable anterior ( no identificado ) : " + nombre + " = " + vValue);
                    :}

                    | LOCAL tipoJuguete:tipo PERSONA:nombre ENTREGA ABREEMPAQUE estampillasNavidena CIERREEMPAQUE
                    {:
                        if(variableDeclarada(nombre)){
                            System.out.println("Error semántico: Variable '" + nombre + "' ya declarada.");
                            compila = false;
                        }
                        listaTablasSimbolos.get(currentHash).add( "Variable (" + tipo.toString() + ") : " + nombre + " = [" + vValue + "]");
                    :}
                    | PERSONA:nombre ABREEMPAQUE tallerDeJuguetes:tp CIERREEMPAQUE ENTREGA tallerDeJuguetes
                    {:
                        verificarDeclaracionVariable(nombre);
                        String tipoAux = tp.toString().split(":")[tp.toString().split(":").length - 1];
                        if (!tipoAux.equals(getTipo(nombre))) {
                            System.out.println("Error semántico: Tipo de dato incorrecto en la asignación de la variable '" + nombre + "'.");
                            compila = false;
                        }
                        listaTablasSimbolos.get(currentHash).add( "Variable anterior (array) : " + nombre + " = [" + vValue + "]");
                    :}
                    | PERSONA:nombre ENTREGA ABREEMPAQUE estampillasNavidena CIERREEMPAQUE
                    {:
                        verificarDeclaracionVariable(nombre);
                        listaTablasSimbolos.get(currentHash).add( "Variable (array) : " + nombre + " = [" + vValue + "]");
                    :}
                    ;

tipoJuguete ::= tipoRegalo:tipo {: RESULT =  tipo; :}
            |  tipoRegalo:tipo ABREEMPAQUE tallerDeJuguetes:val CIERREEMPAQUE
            {: RESULT =  tipo.toString() + "[" + val.toString() + "]"; :}
            ;


//para crear los literales
tallerDeJuguetes ::= piezaJuguete: val
                    {:
                        RESULT =  val.toString();
                        vValue = RESULT.toString().split(":")[0];
                        String tipo = val.toString().split(":")[1].split(" ")[0];
                    :}
                    | piezaJuguete:valA gomasNavidenas:operador tallerDeJuguetes:valB //operando operador operando
                    {:
                        String tpValA = "";
                        String tpValB = "";
                        
                        String valALiteral = valA.toString().replace(":int", "")
                                                    .replace(":float", "").replace(":bool", "").replace(":char", "")
                                                    .replace(":string", "").replace(vValue, "");
                        
                        String valBLiteral = valB.toString().replace(":int", "")
                                                    .replace(":float", "").replace(":bool", "").replace(":char", "")
                                                    .replace(":string", "").replace(vValue, "");

                        try {
                            tpValA = valA.toString().split(":")[1].split(" ")[0];
                        } catch (Exception e) {}

                        try {
                            tpValB = valB.toString().split(":")[1].split(" ")[0];
                        } catch (Exception e) {}

                        if (!checkAritmeticTypeCompatibility(tpValA, operador.toString(), tpValB)) {
                            System.err.println("Error de tipos en la expresión: " + valA.toString() + " " + operador.toString() + " " + valB.toString());
                        }

                        valA = valA.toString().replace(":int", "").replace(":float", "").replace(":bool", "").replace(":char", "").replace(":string", "");


                        RESULT =  valA.toString() + " " + operador.toString() + " " + valB.toString();
                        vValue = RESULT.toString().replace(":int", "").replace(":float", "").replace(":bool", "").replace(":char", "").replace(":string", "");

                        //cod3d mips
                        operador = operador.toString().replace(" ", "");
                        
                        valB = valB.toString().replace(":int", "").replace(":float", "")
                        .replace(":bool", "").replace(":char", "").replace(":string", "");
                        if(tpValA.equals("int") || tpValB.equals("int")) {
                            System.out.println(valA.toString() + " ==== " + operador + " ==== " + valB.toString());
                            if (operador.equals("+")) {
                                if (!valB.toString().contains("+")) {
                                    cod3D.append("add $t" + currentTemp + ", $t" + currentTemp + ", " + valB.toString() + "\n");
                                }
                                cod3D.append("add $t" + currentTemp + ", $t" + currentTemp + ", " + valA.toString() + "\n");
                            } else if (operador.equals("-")) {
                                if (!valB.toString().contains("-") && !valB.toString().contains("(")) {
                                    cod3D.append("sub $t" + currentTemp + ", $t" + currentTemp + ", " + valB.toString() + "\n");
                                }
                                else {//si hay -(expr), entonces, expr (que es lo que se ha operado) cambia su símbolo
                                    if (currentTemp == 0) {
                                        cod3D.append("add $t"+currentTemp+", $t"+currentTemp+", $t" + (currentTemp-1) + "\n");
                                        cod3D.append("mul $t" + currentTemp + ", $t" + currentTemp + ", -1\n");
                                    }
                                    else {
                                        cod3D.append("add $t"+currentTemp+", $t"+currentTemp+", $t" + (currentTemp-1) + "\n");
                                        cod3D.append("mul $t" + (currentTemp - 1) + ", $t" + (currentTemp - 1) + ", -1\n");
                                    }
                                }
                                cod3D.append("add $t" + currentTemp + ", $t" + currentTemp + ", " + valA.toString() + "\n");
                            } else if (operador.equals("*")) {
                                cod3D.append("mul $t2, $t0, $t1\n");
                            } else if (operador.equals("/")) {
                                cod3D.append("div $t2, $t0, $t1\n");
                            } else if (operador.equals("//")) {
                                cod3D.append("div $t2, $t0, $t1\n");
                                cod3D.append("mflo $t2\n");
                            } else if (operador.equals("~")) {
                                cod3D.append("div $t2, $t0, $t1\n");
                                cod3D.append("mfhi $t2\n");
                            } else if (operador.equals("**")) {
                                cod3D.append("mul $t2, $t0, $t1\n");
                            }
                        }
                        else if (tpValA.equals("float") || tpValB.equals("float")) {
                            if (operador.equals("+")) {
                                if (!valB.toString().contains("+")) {
                                    cantidadNumeros++;
                                    cod3D.append("li.s $f"+cantidadNumeros+", " + valA.toString()+"\n");
                                    cantidadNumeros++;
                                    cod3D.append("li.s $f"+cantidadNumeros+", " + valB.toString() +"\n");
                                    cod3D.append("add.s $f0, $f"+(cantidadNumeros-1)+", $f"+cantidadNumeros+"\n");
                                }
                                else {
                                    cod3D.append("add.s $f0, $f0, "+ valA.toString() +"\n");
                                }
                            } else if (operador.equals("-")) {
                                cod3D.append("sub.s $f" + currentTemp + ", " + valALiteral + ", " + valBLiteral + "\n");
                            } else if (operador.equals("*")) {
                                cod3D.append("mul.s $f" + currentTemp + ", " + valALiteral + ", " + valBLiteral + "\n");
                            } else if (operador.equals("/")) {
                                cod3D.append("div.s $f" + currentTemp + ", " + valALiteral + ", " + valBLiteral + "\n");
                            } else if (operador.equals("//")) {
                                cod3D.append("div.s $f" + currentTemp + ", " + valALiteral + ", " + valBLiteral + "\n");
                                cod3D.append("mflo $f" + currentTemp + "\n");
                            } else if (operador.equals("~")) {
                                cod3D.append("div.s $f" + currentTemp + ", " + valALiteral + ", " + valBLiteral + "\n");
                                cod3D.append("mfhi $f" + currentTemp + "\n");
                            } else if (operador.equals("**")) {
                                cod3D.append("mul.s $f" + currentTemp + ", " + valALiteral + ", " + valBLiteral + "\n");
                            }
                        }
                        primeraOp = false;
                    :}
                    | GRINCH:operador tallerDeJuguetes:val
                    {:
                        RESULT = operador.toString() + " " + val.toString();
                        vValue = RESULT.toString();
                    :}
                    | QUIEN:operador tallerDeJuguetes:val
                    {:
                        RESULT = operador.toString() + " " + val.toString();
                        vValue = RESULT.toString();
                    :}
                    | BALTASAR:operador tallerDeJuguetes:val
                    {:
                        RESULT = operador.toString() + " " + val.toString();
                        vValue = RESULT.toString();
                    :}
                    | ABRECUENTO tallerDeJuguetes:val CIERRECUENTO // ( expr )
                    {:
                        //String tipo = val.toString().split(":")[1];
                        String tipo = val.toString().split(":")[val.toString().split(":").length - 1];
                        String valLit = val.toString().replace(":int", "").replace(":float", "").replace(":bool", "").replace(":char", "").replace(":string", "");
                        try {
                            RESULT =  "( " + val.toString() + " ):" + tipo;
                        }
                        catch (Exception e) {
                            RESULT =  "( " + val.toString() + " )";
                        }
                        vValue = "( " + valLit + " )";
                        currentTemp += 1;
                    :}
                    | ABRECUENTO tallerDeJuguetes:valA CIERRECUENTO gomasNavidenas:operador tallerDeJuguetes:valB // ( expr ) gomasNavidenas tallerDeJuguetes
                    {:
                        String tpValA = "";
                        String tpValB = "";
                        String tipo = "";

                        try {
                            tpValA = valA.toString().split(":")[1].split(" ")[0];
                        } catch (Exception e) {}
                        try {
                            tpValB = valB.toString().split(":")[1].split(" ")[0];
                        } catch (Exception e) {}
                        
                        tipo = tpValA.equals("") ? tpValB : tpValA;

                        if (!checkAritmeticTypeCompatibility(tpValA, operador.toString(), tpValB)) {
                            System.out.println("tipoA: " + tpValA + "|  tipoB: " + tpValB);
                            System.err.println("Error de tipos en la expresión: (" + valA.toString() + "):" + tipo + operador.toString() + " " + valB.toString());
                        }
                        
                        valA = valA.toString().replace(":int", "");
                        valA = valA.toString().replace(":float", "");

                        RESULT =  "( " + valA.toString() + " ):" + tipo  + " " + operador.toString() + " " + valB.toString();
                        vValue = "( " + valA.toString() + " ) " + operador.toString() + " " + valB.toString();

                        currentTemp += 1;
                        System.out.println(">>>>>>>>>>>>>>>>>>>>>>>> " + valA.toString());
                        System.out.println(">>>>>>>>>>>>>>>>>>>>>>>> " + valB.toString());

                        valB = valB.toString().replace(":int", "").replace(":float", "").replace(":bool", "").replace(":char", "").replace(":string", "");
                        if(tpValA.equals("int") || tpValB.equals("int")) {
                            System.out.println(valA.toString() + " ==== " + operador + " ==== " + valB.toString());
                            if (operador.equals("+")) {
                                if (!valB.toString().contains("+")) {
                                    cod3D.append("add $t" + currentTemp + ", $t" + currentTemp + ", " + valB.toString() + "\n");
                                }
                                if (!valA.toString().contains("+")){
                                    cod3D.append("add $t" + currentTemp + ", $t" + currentTemp + ", " + valA.toString() + "\n");
                                }

                            } else if (operador.equals("-")) {
                                if (!valB.toString().contains("-") && !valB.toString().contains("(")) {
                                    cod3D.append("sub $t" + currentTemp + ", $t" + currentTemp + ", " + valB.toString() + "\n");
                                }
                                else {//si hay -(expr), entonces, expr (que es lo que se ha operado) cambia su símbolo
                                    if (currentTemp == 0) {
                                        cod3D.append("add $t"+currentTemp+", $t"+currentTemp+", $t" + (currentTemp-1) + "\n");
                                        cod3D.append("mul $t" + currentTemp + ", $t" + currentTemp + ", -1\n");
                                        
                                    }
                                    else {
                                        cod3D.append("add $t"+currentTemp+", $t"+currentTemp+", $t" + (currentTemp-1) + "\n");
                                        cod3D.append("mul $t" + (currentTemp - 1) + ", $t" + (currentTemp - 1) + ", -1\n");
                                    }
                                    
                                }

                                if (!valA.toString().contains("+")) {
                                    cod3D.append("add $t" + currentTemp + ", $t" + currentTemp + ", " + valA.toString() + "\n");
                                }
                            }
                        }
                    :}
                    ;


gomasNavidenas ::= gomaLocaAritmetica:operador {: RESULT = operador; :}
                | gomaLocaRelacional:operador {: RESULT = operador; :}
                | gomaLocaLogica:operador {: RESULT = operador; :}
                ;

piezaJuguete ::= L_SANTACLAUS:val
                {:
                    vValue = val.toString();
                    RESULT =  val.toString() + ":int";
                :}
            | L_PERENOEL:val
                {:
                    vValue = val.toString();
                    RESULT =  val + ":float";
                :}
            | L_FATHERCHRISTMAS:val
                {:
                    vValue = val.toString();
                    RESULT =  val + ":bool";
                :}
            | L_KRISKRINGLE:val
                {:
                    vValue = val.toString();
                    RESULT =  val + ":char";
                :}
            | L_DEDMOROZ:val
                {:
                    vValue = val.toString();
                    RESULT =  val + ":string";
                :}
            | PERSONA:nombre ABREEMPAQUE tallerDeJuguetes:val CIERREEMPAQUE //indice de array
                {:
                    RESULT = nombre + "[" + val.toString() + "]";//TODO: agregar a la tabla de simbolos
                :}
            | PERSONA:nombre
                {:
                    vValue = nombre.toString();
                    RESULT =  nombre + ":" + getTipo(nombre.toString());
                :}
            | piezaImportada:val
                {:
                    RESULT =  val;
                    vValue = RESULT.toString();
                    String nombreFuncion = val.toString().split(":")[0];
                    System.out.println(nombreFuncion);
                    System.out.println("hola");
                    if (!funcionDeclarada(nombreFuncion)) {
                        System.err.println("Error semántico: Función '" + nombreFuncion + "' no declarada.");
                        compila = false;
                    }
                :}
            ;

piezaImportada ::= PERSONA:nombre ABRECUENTO CIERRECUENTO
                    {:
                        System.out.println(nombre);
                        if (!funcionDeclarada(nombre)) {
                            System.err.println("Error semántico: Función '" + nombre + "' no declarada.");
                            compila = false;
                        }
                        RESULT =  nombre + "()";
                        vValue = RESULT.toString();

                    :}
                | PERSONA:nombre ABRECUENTO estampillasNavidena:val CIERRECUENTO
                    {:
                        RESULT =  nombre + "( " + val.toString() + " )";
                        vValue = RESULT.toString();
                    :}
                ;

estampillasNavidena ::= tallerDeJuguetes:val
                        {:
                            RESULT =  val;
                            vValue = RESULT.toString();
                        :}
                    | tallerDeJuguetes:valA COMA estampillasNavidena:valB
                        {:
                            RESULT =  valA.toString() + ", " + valB.toString();
                            vValue = RESULT.toString();
                        :}
                    ;

gomaLocaAritmetica ::= RUDOLPH:operador {: RESULT = operador; :}
                    | DASHER:operador {: RESULT = operador; :}
                    | DANCER:operador {: RESULT = operador; :}
                    | PRANCER:operador {: RESULT = operador; :}
                    | VIXEN:operador {: RESULT = operador; :}
                    | COMET:operador {: RESULT = operador; :}
                    | CUPID:operador {: RESULT = operador; :}
                    ;

gomaLocaRelacional ::= HERMEY:operador {: RESULT = operador; :}
                    | BUDDY:operador {: RESULT = operador; :}
                    | JINGLE:operador {: RESULT = operador; :}
                    | JANGLE:operador {: RESULT = operador; :}
                    | PEPPERMINT:operador {: RESULT = operador; :}
                    | WUNORSE:operador {: RESULT = operador; :}
                    ;

gomaLocaLogica ::= MELCHOR:operador {: RESULT = operador; :}
                | GASPAR:operador {: RESULT = operador; :}
                ;

estructurarJuguete ::= estructurarJuguete_if
                    | estructurarJuguete_if estructurarJuguete_else
                    | estructurarJuguete_if estructurarJuguete_elif
                    | estructurarJuguete_if estructurarJuguete_elif estructurarJuguete_else
                    | estructurarJuguete_for
                    | estructurarJuguete_doUntil
                    ;

estructurarJuguete_if ::= ELFO condiciones bloque;
estructurarJuguete_elif ::= HADA condiciones bloque | HADA condiciones bloque estructurarJuguete_elif;
estructurarJuguete_else ::= DUENDE bloque;
estructurarJuguete_for ::= ENVUELVE encabezado_for bloque;
estructurarJuguete_doUntil ::= HACE bloque REVISA condiciones FINREGALO;

condiciones ::= ABRECUENTO tallerDeJuguetes CIERRECUENTO;
bloque ::= ABREREGALO juguetes CIERRAREGALO;


encabezado_for ::= ABRECUENTO asignarJuguete FINREGALO tallerDeJuguetes FINREGALO tallerDeJuguetes CIERRECUENTO;



/*
TODO: permitir que se pueda llamar funciones con parametros y sin parametros (un parametro puede ser una funcion)✅
TODO: permitir que se pueda llamar una funcion como operando✅
TODO: permitir creación de arreglos✅
TODO: permitir Entrada y salida✅
TODO: permitir Estructuras de control✅
TODO: permitir ciclos✅
*/