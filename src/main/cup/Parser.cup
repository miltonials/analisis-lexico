package com.compi;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.lang.Math;

//para errores
import java_cup.runtime.Symbol;

//para tablas de simbolos
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

/**
 * Clase principal del compilador
 */
class Parser;


action code {:
        HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<String, ArrayList<String>>();
        String currentHash;
        boolean compila = true;
        String vName;
        String vValue;
        char vValueCharmander;

        StringBuffer cod3D = new StringBuffer();
        int currentTemp = 1;

        /**
         * Imprime la tabla de símbolos
        */
        public void imprimirTablaSimbolos () {
            System.out.println("_________________________Tablas de símbolos_________________________");
            for(String key: listaTablasSimbolos.keySet()) {
                System.out.println("Tabla de símbolos: " + key);
                System.out.println("valores: ");
                for (String item : listaTablasSimbolos.get(key)) {
                    System.out.println(item);
                }
                System.out.println("");
            }
            System.out.println("______________________________________________________________________");
        }

        /**
         * Agrega una tabla de símbolos a la lista de tablas de símbolos
         * @param tipo tipo de la tabla de símbolos
         * @param nombreFuncion nombre de la función a la que pertenece la tabla de símbolos
         */
        public void agregarTablaSimbolos (String tipo, String nombreFuncion) {
            String tipoTabla = "Tipo: " + tipo;
            ArrayList<String> funcionMain = new ArrayList<String>();
            currentHash = nombreFuncion;
            funcionMain.add(tipoTabla);
            listaTablasSimbolos.put(currentHash, funcionMain);
        }

        /*
         * muestra el error de sintaxis
         * @param mensaje error
         */
        public void error(String mensaje) {
            System.out.println(mensaje);
        }
        
        public String getTipo(String id) {
            //buscar en la tabla de simbolos actual
            for (String item : listaTablasSimbolos.get(currentHash)) {
                boolean x = item.contains(id);
                if (item.contains(id)) {
                    String title = item.split(":")[0];
                    return title.substring(title.indexOf("(") + 1, title.indexOf(")"));
                }
            }
            return "null";
        }
        
        /**
        * Checks if the arithmetic operation between two operands is type-compatible.
        * Assumes that the types are either "int" or "float".
        * 
        * @param type1 Type of the first operand
        * @param operator Arithmetic operator
        * @param type2 Type of the second operand
        * @return true if the types are compatible, false otherwise
        */
        public boolean checkAritmeticTypeCompatibility(String type1, String operator, String type2) {
            // Ensure both operands are only "int" or "float"
            boolean isInt1 = type1.equals("int") && (type2.equals("int") || type2.equals(""));
            boolean isInt2 = (type1.equals("int") || type1.equals("")) && type2.equals("int");
            boolean isFloat1 = type1.equals("float") && (type2.equals("float") || type2.equals(""));
            boolean isFloat2 = (type1.equals("float") || type1.equals("")) && type2.equals("float");

            boolean isInt = isInt1 || isInt2;
            boolean isFloat = isFloat1 || isFloat2;
            if (!isInt && !isFloat) {
                return false;
            }

            // Check for specific operator rules
            if (operator.equals("+")
                || operator.equals("-")
                || operator.equals("*")
                || operator.equals("/")
                || operator.equals("//")
                || operator.equals("~")
                || operator.equals("**")
                ) {
                // Allow addition, subtraction, multiplication, and division for both "int" and "float"
                return true;
            }

            // Default case
            return false;
        }

:}

parser code {:
        IdLexer miParser;
        // Habilitar la depuración
        boolean _cup_debug = true;
        List<String> syntaxErrors = new ArrayList<>();

        String tipoRetornoActual = null;

        /**
         * Establece el tipo de retorno actual
         * @param tipo tipo de retorno actual
         */
        public void setTipoRetorno(String tipo) {
                tipoRetornoActual = tipo;
        }

        /**
         * Verifica que el tipo de retorno sea el correcto
         * @param tipoReal tipo de retorno real
         */
        public void checkTipoRetorno(String tipoReal) {
                if (tipoRetornoActual != null && !tipoRetornoActual.equals(tipoReal)) {
                        System.err.println("Tipo de retorno incorrecto. Se esperaba: " + tipoRetornoActual + ", pero se encontró: " + tipoReal);
                }
        }

        // Agregar un método para obtener la lista de errores después del análisis
        /**
         * Obtiene la lista de errores de sintaxis
         * @return lista de errores de sintaxis
         */
        public List<String> getSyntaxErrors() {
                return syntaxErrors;
        }

        @SuppressWarnings("deprecation")
        public Parser(IdLexer miParser) {
                this.miParser = miParser;
                this.symbolFactory = new DefaultSymbolFactory();
        }

        /**
         * captura los errores de sintaxis 
         * @param s error
         */
        public void syntax_error(Symbol s) {
                try {
                        String errorMessage = "Error de sintaxis: " + s.value + " en la línea " + (s.left + 1) + " columna " + (s.right + 1);
                        System.err.println(errorMessage);
                        // Agregar lógica adicional si es necesario para errores recuperables
                        //throw new Exception("Error recuperable");
                } catch (Exception e) {
                        System.err.println("Hola");
                        System.err.println("Error de sintaxis: " + e.getMessage());
                }
        }

        /**
         * captura los errores de sintaxis no recuperables
         * @param s error
         */
        public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
                String errorMessage = "Error de sintaxis no recuperable: " + s.value + " en la línea " + (s.left + 1) + " columna " + (s.right + 1);
                System.err.println(errorMessage);

                // Agregar lógica adicional si es necesario para errores no recuperables
                // throw new Exception("Error no recuperable");
        }
:}


init with {: :};

scan with {: return miParser.next_token(); :};

/* Terminales */

// Operadores aritméticos binarios
terminal String RUDOLPH; // +
terminal String DASHER; // -
terminal String  DANCER; // /
terminal String  PRANCER; // // (division entera)
terminal String  VIXEN; // *
terminal String  COMET; // ~
terminal String CUPID; // **
// Operadores aritméticos unarios
terminal String  GRINCH; // ++
terminal String  QUIEN; // --
// Operadores relacionales
terminal String  HERMEY; // <
terminal String  BUDDY; // =<
terminal String  JINGLE; // >
terminal String JANGLE; // >=
terminal String  PEPPERMINT; // ==
terminal String  WUNORSE; // !=
// Operadores lógicos
terminal String  MELCHOR; // ^
terminal String  GASPAR; // #
terminal String BALTASAR; // !
terminal  LOCAL; // variable

// Tipos
terminal String PERSONA; // identificador
terminal String SANTACLAUS; // int
terminal String PERENOEL; // float
terminal String FATHERCHRISTMAS; // boolean
terminal String KRISKRINGLE; // char
terminal String DEDMOROZ; // string
terminal Integer[] PAPANOEL; // array
terminal Integer L_SANTACLAUS; // literal int
terminal Double L_PERENOEL; // literal float
//terminal Boolean L_FATHERCHRISTMAS; // literal boolean
terminal String L_FATHERCHRISTMAS; // literal boolean
terminal String L_KRISKRINGLE; // literal char
terminal String L_DEDMOROZ; // literal string
//terminal Integer[] L_PAPANOEL; // literal array

// Parentesis
terminal String ABRECUENTO; // (
terminal String CIERRECUENTO; // )
terminal String ABREEMPAQUE; // [
terminal String CIERREEMPAQUE; // ]
terminal String ABREREGALO; // {
terminal String CIERRAREGALO; // }

// Estructuras de control
terminal String ELFO;//if
terminal String HADA;//else
terminal String DUENDE;//else
terminal String ENVUELVE;//for
terminal String HACE;//do
terminal String REVISA;//until
terminal String ENVIA;//return
terminal String CORTA;//break

// Entrada y salida
terminal Integer NARRA;//print
terminal Integer ESCUCHA;//read 

// Fin de expresión
terminal  FINREGALO; // |

// Lexema separador
terminal String COMA; //,

// Asignación
terminal Integer ENTREGA;//<=

// Comentarios
// son ignorados por el compilador

// Funciones
terminal Integer MAIN; //main
terminal Integer REGALO; // definicion de funcion 

//-------------------------------------------------------------------------------------- NO Terminales
non terminal navidad; // Símbolo inicial ✅
non terminal bolsanavidena; // produccion para funciones ✅
non terminal regaloprincipal; // produccion para main ✅
non terminal regalofuncional; // produccion para funciones ✅
non terminal tipoRegalo; // produccion para tipo de funcion ✅
non terminal monnos; // produccion para parametros ✅
non terminal juguetes; // produccion para cuerpo de funcion ✅
non terminal juguete; // produccion para cuerpo de funcion ✅
non terminal tallerDeJuguetes; // produccion para cuerpo de funcion ✅
non terminal piezaJuguete; // produccion para cuerpo de funcion ✅
non terminal gomaLocaAritmetica; // produccion para cuerpo de funcion ✅
non terminal gomaLocaRelacional; // produccion para cuerpo de funcion ✅
non terminal gomaLocaLogica; // produccion para cuerpo de funcion ✅
non terminal asignarJuguete;
non terminal tipoJuguete;
non terminal subtipoRegalo;
non terminal gomasNavidenas;
non terminal piezaImportada;
non terminal estampillasNavidena;
non terminal estructurarJuguete;
non terminal estructurarJuguete_if;
non terminal estructurarJuguete_elif;
non terminal estructurarJuguete_else;
non terminal condiciones;
non terminal bloque;

non terminal estructurarJuguete_for;
non terminal encabezado_for;
non terminal estructurarJuguete_doUntil;
non terminal bolsaFuncional;
non terminal monnosAux;
//-------------------------------------------------------------------------------------- PRECEDENCIA






//-------------------------------------------------------------------------------------- PRODUCCIONES
/* Símbolo inicial y producciones gramaticales*/
start with navidad;

/* Producciones gramaticales */
navidad ::= 
        bolsanavidena
        {:
            imprimirTablaSimbolos();
            System.out.println("Fin de ejecución");
            
            if (compila) {
                System.out.println("Compilación exitosa");
            } else {
                System.out.println("Compilación fallida");
            }
        :}
        ;

bolsanavidena ::=  regaloprincipal
                | bolsaFuncional regaloprincipal;

bolsaFuncional ::= regalofuncional | bolsaFuncional regalofuncional;

regaloprincipal ::= REGALO SANTACLAUS MAIN ABRECUENTO  CIERRECUENTO ABREREGALO
                        {:
                            agregarTablaSimbolos("int", "main");
                        :}
                        juguetes
                    CIERRAREGALO;

regalofuncional ::= REGALO tipoRegalo:tipo PERSONA:nombre monnosAux ABREREGALO
                    {:
                        agregarTablaSimbolos(tipo.toString(), nombre.toString());
                    :}
                    juguetes
                    CIERRAREGALO
                    ;
                    
monnosAux ::= ABRECUENTO monnos CIERRECUENTO | ABRECUENTO CIERRECUENTO;

tipoRegalo ::=  PERENOEL:tipo {: RESULT =  tipo; :}
            | FATHERCHRISTMAS:tipo {: RESULT =  tipo; :}
            | subtipoRegalo:tipo {: RESULT =  tipo; :}
            | DEDMOROZ:tipo {: RESULT =  tipo; :}
            | PAPANOEL:tipo {: RESULT =  tipo; :}
            ;

subtipoRegalo ::= SANTACLAUS:tipo {: RESULT =  tipo; :}
                | KRISKRINGLE:tipo {: RESULT =  tipo; :}
                ;

monnos ::= tipoRegalo:tipo PERSONA:nombre
                {:
                    agregarTablaSimbolos(tipo.toString(), nombre.toString());
                :} 
            | tipoRegalo:tipo PERSONA:nombre COMA monnos;


juguetes ::= juguete
            | juguete juguetes;

juguete ::= asignarJuguete FINREGALO
            | piezaImportada FINREGALO
            | estructurarJuguete
            | CORTA FINREGALO
            | ENVIA tallerDeJuguetes FINREGALO
            | NARRA tallerDeJuguetes FINREGALO
            | ESCUCHA tallerDeJuguetes FINREGALO
            ;

asignarJuguete ::= LOCAL tipoJuguete:tipo PERSONA:nombre ENTREGA tallerDeJuguetes
                    {:
                        listaTablasSimbolos.get(currentHash).add( "Variable (" + tipo.toString() + ") : " + nombre + " = " + vValue);
                    :}
                    | LOCAL tipoJuguete:tipo PERSONA:nombre
                    {:
                        listaTablasSimbolos.get(currentHash).add( "Variable (" + tipo.toString() + ") : " + nombre);
                    :}
                    | PERSONA:nombre ENTREGA tallerDeJuguetes
                    {:
                        listaTablasSimbolos.get(currentHash).add( "Variable anterior ( no identificado ) : " + nombre + " = " + vValue);
                    :}

                    | LOCAL tipoJuguete:tipo PERSONA:nombre ENTREGA ABREEMPAQUE estampillasNavidena CIERREEMPAQUE
                    {:
                        listaTablasSimbolos.get(currentHash).add( "Variable (" + tipo.toString() + ") : " + nombre + " = [" + vValue + "]");
                    :}
                    | PERSONA:nombre ABREEMPAQUE tallerDeJuguetes CIERREEMPAQUE ENTREGA tallerDeJuguetes
                    {:
                        listaTablasSimbolos.get(currentHash).add( "Variable anterior (array) : " + nombre + " = [" + vValue + "]");
                    :}
                    | PERSONA:nombre ENTREGA ABREEMPAQUE estampillasNavidena CIERREEMPAQUE
                    {:
                        listaTablasSimbolos.get(currentHash).add( "Variable (array) : " + nombre + " = [" + vValue + "]");
                    :}
                    ;

tipoJuguete ::= tipoRegalo:tipo {: RESULT =  tipo; :}
            |  tipoRegalo:tipo ABREEMPAQUE tallerDeJuguetes:val CIERREEMPAQUE
            {: RESULT =  tipo.toString() + "[" + val.toString() + "]"; :}
            ;


//para crear los literales
tallerDeJuguetes ::= piezaJuguete: val
                    {:
                        RESULT =  val;
                        vValue = RESULT.toString();
                    :}
                    | piezaJuguete:valA gomasNavidenas:operador tallerDeJuguetes:valB
                    {:
                        String valALit = "";
                        String valBLit = "";
                        String valATipo = "";
                        String valBTipo = "";

                        System.out.println(valA.toString() + " " + operador.toString() + " " + valB.toString());
                        valALit = valA.toString().split(":")[0];
                        valATipo = valA.toString().split(":")[1];
                        try {
                            valBLit = valB.toString().split(":")[0];
                            valBTipo = valB.toString().split(":")[1];
                        }
                        catch (Exception e){
                        //nothing
                        }

                        RESULT =  valALit + " " + operador.toString() + " " + valBLit;
                        vValue = RESULT.toString();
                        
                        //validarTipos
                        if (!checkAritmeticTypeCompatibility(valATipo, operador.toString(), valBTipo)) {
                            System.err.println("Error de tipos en la expresión: " + valA.toString() + " " + operador.toString() + " " + valB.toString());
                        }
                    :}
                    | GRINCH:operador tallerDeJuguetes:val
                    {:
                        RESULT = operador.toString() + " " + val.toString();
                        vValue = RESULT.toString();
                    :}
                    | QUIEN:operador tallerDeJuguetes:val
                    {:
                        RESULT = operador.toString() + " " + val.toString();
                        vValue = RESULT.toString();
                    :}
                    | BALTASAR:operador tallerDeJuguetes:val
                    {:
                        RESULT = operador.toString() + " " + val.toString();
                        vValue = RESULT.toString();
                    :}
                    | ABRECUENTO tallerDeJuguetes:val CIERRECUENTO // ( expr )
                    {:
                        RESULT =  "( " + val.toString() + " )";
                        vValue = RESULT.toString();
                        RESULT =  val.toString();
                        System.out.println("jdslfjk: " + RESULT.toString());
                    :}
                    | ABRECUENTO tallerDeJuguetes:valA CIERRECUENTO gomasNavidenas:operador tallerDeJuguetes:valB // ( expr ) gomasNavidenas tallerDeJuguetes
                    {:
                        RESULT =  "( " + valA.toString() + " ) " + operador.toString() + " " + valB.toString();
                        vValue = RESULT.toString();
                        RESULT =  valA.toString() + operador.toString() + " " + valB.toString();

                        //System.out.println("popopo: " + RESULT.toString());
                        //validarTipos
                        System.out.println(valA.toString() + " " + operador.toString() + " " + valB.toString());                        
                        String valATipo = "";
                        String valBTipo = "";

                        try {
                            valATipo = valA.toString().split(":")[1];
                        }
                        catch (Exception e){
                        //nothing
                        }
                        try {
                            valBTipo = valB.toString().split(":")[1];
                        }
                        catch (Exception e){
                        //nothing
                        }

                        if (!checkAritmeticTypeCompatibility(valATipo, operador.toString(), valBTipo)) {
                            System.err.println("Error de tipos en la expresión: " + valA.toString() + " " + operador.toString() + " " + valB.toString());
                        }
                    :}
                    ;

gomasNavidenas ::= gomaLocaAritmetica:operador {: RESULT = operador; :}
                | gomaLocaRelacional:operador {: RESULT = operador; :}
                | gomaLocaLogica:operador {: RESULT = operador; :}
                ;

piezaJuguete ::= L_SANTACLAUS:val
                {:
                    vValue = val.toString();
                    RESULT =  val.toString() + ":int";
                :}
            | L_PERENOEL:val
                {:
                    vValue = val.toString();
                    RESULT =  val + ":float";
                :}
            | L_FATHERCHRISTMAS:val
                {:
                    vValue = val.toString();
                    RESULT =  val + ":bool";
                :}
            | L_KRISKRINGLE:val
                {:
                    vValue = val.toString();
                    RESULT =  val + ":char";
                :}
            | L_DEDMOROZ:val
                {:
                    vValue = val.toString();
                    RESULT =  val + ":string";
                :}
            | PERSONA:nombre ABREEMPAQUE tallerDeJuguetes:val CIERREEMPAQUE //indice de array
                {:
                    RESULT = nombre + "[" + val.toString() + "]";//TODO: agregar a la tabla de simbolos
                :}
            | PERSONA:nombre
                {:
                    vValue = nombre.toString();
                    RESULT =  nombre + ":" + getTipo(nombre.toString());
                :}
            | piezaImportada:val
                {:
                    RESULT =  val;
                    vValue = RESULT.toString();
                :}
            ;

piezaImportada ::= PERSONA:nombre ABRECUENTO CIERRECUENTO
                    {:
                        RESULT =  nombre + "()";
                        vValue = RESULT.toString();
                    :}
                | PERSONA:nombre ABRECUENTO estampillasNavidena:val CIERRECUENTO
                    {:
                        RESULT =  nombre + "( " + val.toString() + " )";
                        vValue = RESULT.toString();
                    :}
                ;

estampillasNavidena ::= tallerDeJuguetes:val
                        {:
                            RESULT =  val;
                            vValue = RESULT.toString();
                        :}
                    | tallerDeJuguetes:valA COMA estampillasNavidena:valB
                        {:
                            RESULT =  valA.toString() + ", " + valB.toString();
                            vValue = RESULT.toString();
                        :}
                    ;

gomaLocaAritmetica ::= RUDOLPH:operador {: RESULT = operador; :}
                    | DASHER:operador {: RESULT = operador; :}
                    | DANCER:operador {: RESULT = operador; :}
                    | PRANCER:operador {: RESULT = operador; :}
                    | VIXEN:operador {: RESULT = operador; :}
                    | COMET:operador {: RESULT = operador; :}
                    | CUPID:operador {: RESULT = operador; :}
                    ;

gomaLocaRelacional ::= HERMEY:operador {: RESULT = operador; :}
                    | BUDDY:operador {: RESULT = operador; :}
                    | JINGLE:operador {: RESULT = operador; :}
                    | JANGLE:operador {: RESULT = operador; :}
                    | PEPPERMINT:operador {: RESULT = operador; :}
                    | WUNORSE:operador {: RESULT = operador; :}
                    ;

gomaLocaLogica ::= MELCHOR:operador {: RESULT = operador; :}
                | GASPAR:operador {: RESULT = operador; :}
                ;

estructurarJuguete ::= estructurarJuguete_if
                    | estructurarJuguete_if estructurarJuguete_else
                    | estructurarJuguete_if estructurarJuguete_elif
                    | estructurarJuguete_if estructurarJuguete_elif estructurarJuguete_else
                    | estructurarJuguete_for
                    | estructurarJuguete_doUntil
                    ;

estructurarJuguete_if ::= ELFO condiciones bloque;
estructurarJuguete_elif ::= HADA condiciones bloque | HADA condiciones bloque estructurarJuguete_elif;
estructurarJuguete_else ::= DUENDE bloque;
estructurarJuguete_for ::= ENVUELVE encabezado_for bloque;
estructurarJuguete_doUntil ::= HACE bloque REVISA condiciones FINREGALO;

condiciones ::= ABRECUENTO tallerDeJuguetes CIERRECUENTO;
bloque ::= ABREREGALO juguetes CIERRAREGALO;


encabezado_for ::= ABRECUENTO asignarJuguete FINREGALO tallerDeJuguetes FINREGALO tallerDeJuguetes CIERRECUENTO;



/*
TODO: permitir que se pueda llamar funciones con parametros y sin parametros (un parametro puede ser una funcion)✅
TODO: permitir que se pueda llamar una funcion como operando✅
TODO: permitir creación de arreglos✅
TODO: permitir Entrada y salida✅
TODO: permitir Estructuras de control✅
TODO: permitir ciclos✅
*/